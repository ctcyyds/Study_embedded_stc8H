C51 COMPILER V9.60.7.0   I2C                                                               04/20/2023 09:24:21 PAGE 1   


C51 COMPILER V9.60.7.0, COMPILATION OF MODULE I2C
OBJECT MODULE PLACED IN .\Objects\I2C.obj
COMPILER INVOKED BY: D:\instal\Keil_v5\C51\BIN\C51.EXE I2C.c LARGE OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\L
                    -istings\I2C.lst) TABS(2) OBJECT(.\Objects\I2C.obj)

line level    source

   1          /*---------------------------------------------------------------------*/
   2          /* --- STC MCU Limited ------------------------------------------------*/
   3          /* --- STC 1T Series MCU Demo Programme -------------------------------*/
   4          /* --- Mobile: (86)13922805190 ----------------------------------------*/
   5          /* --- Fax: 86-0513-55012956,55012947,55012969 ------------------------*/
   6          /* --- Tel: 86-0513-55012928,55012929,55012966 ------------------------*/
   7          /* --- Web: www.STCMCU.com --------------------------------------------*/
   8          /* --- Web: www.STCMCUDATA.com  ---------------------------------------*/
   9          /* --- QQ:  800003751 -------------------------------------------------*/
  10          /* 如果要在程序中使用此代码,请在程序中注明使用了STC的资料及程序            */
  11          /*---------------------------------------------------------------------*/
  12          
  13          #include  "I2C.h"
  14          
  15          u8  I2C_BUF_type I2C_RxBuffer[I2C_BUF_LENTH];
  16          
  17          #define SLAW    0xA2
  18          #define SLAR    0xA3
  19          
  20          //========================================================================
  21          // 函数: void I2C_Init(I2C_InitTypeDef *I2Cx)
  22          // 描述: I2C初始化程序.
  23          // 参数: I2Cx: 结构参数,请参考I2C.h里的定义.
  24          // 返回: none.
  25          // 版本: V1.0, 2012-11-22
  26          //========================================================================
  27          void  I2C_Init(I2C_InitTypeDef *I2Cx)
  28          {
  29   1          EAXSFR();   /* MOVX A,@DPTR/MOVX @DPTR,A指令的操作对象为扩展SFR(XSFR) */
  30   1      
  31   1          if(I2Cx->I2C_Mode == I2C_Mode_Master)
  32   1          {
  33   2              I2C_Master();     //设为主机
  34   2              I2CMSST = 0x00;   //清除I2C主机状态寄存器
  35   2              I2C_Master_Inturrupt(I2Cx->I2C_MS_Interrupt);
  36   2              I2C_SetSpeed(I2Cx->I2C_Speed);
  37   2              if(I2Cx->I2C_MS_WDTA == ENABLE)   I2C_WDTA_EN();  //使能自动发送
  38   2              else                  I2C_WDTA_DIS(); //禁止自动发送
  39   2          }
  40   1          else
  41   1          {
  42   2              I2C_Slave();  //设为从机
  43   2              I2CSLST = 0x00;   //清除I2C从机状态寄存器
  44   2              if(I2Cx->I2C_SL_ESTAI == ENABLE)    I2C_ESTAI_EN(); //使能从机接收START信号中断
  45   2              else                  I2C_ESTAI_DIS();  //禁止从机接收START信号中断
  46   2              if(I2Cx->I2C_SL_ERXI == ENABLE)   I2C_ERXI_EN();  //使能从机接收1字节数据中断
  47   2              else                  I2C_ERXI_DIS(); //禁止从机接收1字节数据中断
  48   2              if(I2Cx->I2C_SL_ETXI == ENABLE)   I2C_ETXI_EN();  //使能从机发送1字节数据中断
  49   2              else                  I2C_ETXI_DIS(); //禁止从机发送1字节数据中断
  50   2              if(I2Cx->I2C_SL_ESTOI == ENABLE)    I2C_ESTOI_EN(); //使能从机接收STOP信号中断
  51   2              else                  I2C_ESTOI_DIS();  //禁止从机接收STOP信号中断
  52   2              I2C_Address(I2Cx->I2C_SL_ADR);
  53   2              if(I2Cx->I2C_SL_MA == ENABLE)   I2C_MATCH_EN(); //从机地址比较功能，只接受相匹配地址
  54   2              else                  I2C_MATCH_DIS();  //禁止从机地址比较功能，接受所有设备地址
C51 COMPILER V9.60.7.0   I2C                                                               04/20/2023 09:24:21 PAGE 2   

  55   2          }
  56   1      
  57   1          P_SW2 = (P_SW2 & ~(3<<4)) | I2Cx->I2C_IoUse;
  58   1          I2C_Function(I2Cx->I2C_Enable);
  59   1      
  60   1          EAXRAM();   /* MOVX A,@DPTR/MOVX @DPTR,A指令的操作对象为扩展RAM(XRAM) */
  61   1      }
  62          
  63          //========================================================================
  64          // 函数: void Wait (void)
  65          // 描述: 等待主机模式I2C控制器执行完成I2CMSCR.
  66          // 参数: mode: 指定模式, 取值 I2C_Mode_Master 或 I2C_Mode_Slave.
  67          // 返回: none.
  68          // 版本: V1.0, 2012-11-22
  69          //========================================================================
  70          void Wait()
  71          {
  72   1          while (!(I2CMSST & 0x40));
  73   1          I2CMSST &= ~0x40;
  74   1      }
  75          
  76          //========================================================================
  77          // 函数: void Start (void)
  78          // 描述: I2C总线起始函数.
  79          // 参数: none.
  80          // 返回: none.
  81          // 版本: V1.0, 2020-09-15
  82          //========================================================================
  83          void Start()
  84          {
  85   1          I2CMSCR = 0x01;                         //发送START命令
  86   1          Wait();
  87   1      }
  88          
  89          //========================================================================
  90          // 函数: void SendData (char dat)
  91          // 描述: I2C发送一个字节数据函数.
  92          // 参数: 发送的数据.
  93          // 返回: none.
  94          // 版本: V1.0, 2020-09-15
  95          //========================================================================
  96          void SendData(char dat)
  97          {
  98   1          I2CTXD = dat;                           //写数据到数据缓冲区
  99   1          I2CMSCR = 0x02;                         //发送SEND命令
 100   1          Wait();
 101   1      }
 102          
 103          //========================================================================
 104          // 函数: void RecvACK (void)
 105          // 描述: I2C获取ACK函数.
 106          // 参数: none.
 107          // 返回: none.
 108          // 版本: V1.0, 2020-09-15
 109          //========================================================================
 110          void RecvACK()
 111          {
 112   1          I2CMSCR = 0x03;                         //发送读ACK命令
 113   1          Wait();
 114   1      }
 115          
 116          //========================================================================
C51 COMPILER V9.60.7.0   I2C                                                               04/20/2023 09:24:21 PAGE 3   

 117          // 函数: char RecvData (void)
 118          // 描述: I2C读取一个字节数据函数.
 119          // 参数: none.
 120          // 返回: 读取数据.
 121          // 版本: V1.0, 2020-09-15
 122          //========================================================================
 123          char RecvData()
 124          {
 125   1          I2CMSCR = 0x04;                         //发送RECV命令
 126   1          Wait();
 127   1          return I2CRXD;
 128   1      }
 129          
 130          //========================================================================
 131          // 函数: void SendACK (void)
 132          // 描述: I2C发送ACK函数.
 133          // 参数: none.
 134          // 返回: none.
 135          // 版本: V1.0, 2020-09-15
 136          //========================================================================
 137          void SendACK()
 138          {
 139   1          I2CMSST = 0x00;                         //设置ACK信号
 140   1          I2CMSCR = 0x05;                         //发送ACK命令
 141   1          Wait();
 142   1      }
 143          
 144          //========================================================================
 145          // 函数: void SendNAK (void)
 146          // 描述: I2C发送NAK函数.
 147          // 参数: none.
 148          // 返回: none.
 149          // 版本: V1.0, 2020-09-15
 150          //========================================================================
 151          void SendNAK()
 152          {
 153   1          I2CMSST = 0x01;                         //设置NAK信号
 154   1          I2CMSCR = 0x05;                         //发送ACK命令
 155   1          Wait();
 156   1      }
 157          
 158          //========================================================================
 159          // 函数: void Stop (void)
 160          // 描述: I2C总线停止函数.
 161          // 参数: none.
 162          // 返回: none.
 163          // 版本: V1.0, 2020-09-15
 164          //========================================================================
 165          void Stop()
 166          {
 167   1          I2CMSCR = 0x06;                         //发送STOP命令
 168   1          Wait();
 169   1      }
 170          
 171          //========================================================================
 172          // 函数: void WriteNbyte(u8 addr, u8 *p, u8 number)
 173          // 描述: I2C写入数据函数.
 174          // 参数: addr: 指定地址, *p写入数据存储位置, number写入数据个数.
 175          // 返回: none.
 176          // 版本: V1.0, 2020-09-15
 177          //========================================================================
 178          void WriteNbyte(u8 addr, u8 *p, u8 number)  /*  WordAddress,First Data Address,Byte lenth   */
C51 COMPILER V9.60.7.0   I2C                                                               04/20/2023 09:24:21 PAGE 4   

 179          {
 180   1          EAXSFR();   /* MOVX A,@DPTR/MOVX @DPTR,A指令的操作对象为扩展SFR(XSFR) */
 181   1          Start();                                //发送起始命令
 182   1          SendData(SLAW);                         //发送设备地址+写命令
 183   1          RecvACK();
 184   1          SendData(addr);                         //发送存储地址
 185   1          RecvACK();
 186   1          do
 187   1          {
 188   2              SendData(*p++);
 189   2              RecvACK();
 190   2          }
 191   1          while(--number);
 192   1          Stop();                                 //发送停止命令
 193   1          EAXRAM();   /* MOVX A,@DPTR/MOVX @DPTR,A指令的操作对象为扩展RAM(XRAM) */
 194   1      }
 195          
 196          //========================================================================
 197          // 函数: void ReadNbyte(u8 addr, u8 *p, u8 number)
 198          // 描述: I2C读取数据函数.
 199          // 参数: addr: 指定地址, *p读取数据存储位置, number读取数据个数.
 200          // 返回: none.
 201          // 版本: V1.0, 2020-09-15
 202          //========================================================================
 203          void ReadNbyte(u8 addr, u8 *p, u8 number)   /*  WordAddress,First Data Address,Byte lenth   */
 204          {
 205   1          EAXSFR();   /* MOVX A,@DPTR/MOVX @DPTR,A指令的操作对象为扩展SFR(XSFR) */
 206   1          Start();                                //发送起始命令
 207   1          SendData(SLAW);                         //发送设备地址+写命令
 208   1          RecvACK();
 209   1          SendData(addr);                         //发送存储地址
 210   1          RecvACK();
 211   1          Start();                                //发送起始命令
 212   1          SendData(SLAR);                         //发送设备地址+读命令
 213   1          RecvACK();
 214   1          do
 215   1          {
 216   2              *p = RecvData();
 217   2              p++;
 218   2              if(number != 1) SendACK();          //send ACK
 219   2          }
 220   1          while(--number);
 221   1          SendNAK();                              //send no ACK
 222   1          Stop();                                 //发送停止命令
 223   1          EAXRAM();   /* MOVX A,@DPTR/MOVX @DPTR,A指令的操作对象为扩展RAM(XRAM) */
 224   1      }
 225          
 226          //========================================================================
 227          // 函数: void I2C_Isr (void) interrupt I2C_VECTOR
 228          // 描述: I2C中断函数.
 229          // 参数: none.
 230          // 返回: none.
 231          // 版本: V1.0, 2020-09-15
 232          //========================================================================
 233          void I2C_Isr() interrupt I2C_VECTOR
 234          {
 235   1          char store;
 236   1      
 237   1          store = P_SW2;
 238   1          P_SW2 |= 0x80;
 239   1      
 240   1          //Add user code here.
C51 COMPILER V9.60.7.0   I2C                                                               04/20/2023 09:24:21 PAGE 5   

 241   1      
 242   1          P_SW2 = store;
 243   1      }
 244          
 245          void I2C_WriteNbyte(u8 addr, u8 reg, u8 *p, u8 number) {
 246   1          EAXSFR();   /* MOVX A,@DPTR/MOVX @DPTR,A指令的操作对象为扩展SFR(XSFR) */
 247   1          Start();                                //发送起始命令
 248   1          SendData((addr << 1));                         //发送设备地址+写命令
 249   1          RecvACK();
 250   1          SendData(reg);                         //发送存储地址
 251   1          RecvACK();
 252   1          do
 253   1          {
 254   2              SendData(*p++);
 255   2              RecvACK();
 256   2          }
 257   1          while(--number);
 258   1          Stop();                                 //发送停止命令
 259   1          EAXRAM();   /* MOVX A,@DPTR/MOVX @DPTR,A指令的操作对象为扩展RAM(XRAM) */
 260   1      }
 261          
 262          void I2C_ReadNbyte( u8 addr, u8 reg, u8 *p, u8 number) {
 263   1          EAXSFR();   /* MOVX A,@DPTR/MOVX @DPTR,A指令的操作对象为扩展SFR(XSFR) */
 264   1          Start();                                //发送起始命令
 265   1          SendData((addr << 1));                         //发送设备地址+写命令
 266   1          RecvACK();
 267   1          SendData(reg);                         //发送存储地址
 268   1          RecvACK();
 269   1          Start();                                //发送起始命令
 270   1          SendData((addr << 1) | 0x01);           //发送设备地址+读命令
 271   1          RecvACK();
 272   1          do
 273   1          {
 274   2              *p = RecvData();
 275   2              p++;
 276   2              if(number != 1) SendACK();          //send ACK
 277   2          }
 278   1          while(--number);
 279   1          SendNAK();                              //send no ACK
 280   1          Stop();                                 //发送停止命令
 281   1          EAXRAM();   /* MOVX A,@DPTR/MOVX @DPTR,A指令的操作对象为扩展RAM(XRAM) */
 282   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    638    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =    128      22
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
